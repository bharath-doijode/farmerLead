{"version":3,"file":"vendors-node_modules_callstack_repack_client_js.chunk.bundle","mappings":"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;;AAED;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,sBAAsB;AACxC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA,SAAS,yBAAyB;AAClC;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,8DAA8D,YAAY;AAC1E;AACA,8DAA8D,YAAY;AAC1E;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,qCAAqC,YAAY;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;;;;;;;;;;;AChfA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,oBAAoB,oBAAoB;AACxC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA","sources":["webpack:///./node_modules/@callstack/repack/client.js","webpack:///../../../src/modules/ScriptManager/Script.ts","webpack:///../../../src/modules/ScriptManager/ScriptManager.ts","webpack:///../../../src/modules/ScriptManager/federated.ts","webpack:///../../../src/modules/ScriptManager/getWebpackContext.ts","webpack:///../../../src/modules/ScriptManager/index.ts","webpack:///./node_modules/events/events.js","webpack:///./node_modules/shallowequal/index.js"],"sourcesContent":["export * from './dist/modules/ScriptManager';\n","/* globals Headers, FormData */\n\nimport shallowEqual from 'shallowequal';\nimport type {\n  NormalizedScriptLocator,\n  ScriptLocator,\n  WebpackContext,\n} from './types';\n\n/**\n * Representation of a Script to load and execute, used by {@link ScriptManager}.\n *\n * When adding resolvers to `ScriptManager` in `ScriptManager.shared.addResolver(...)`, you can use\n * `Script.getDevServerURL(...)`, `Script.getFileSystemURL(...)` or `Script.getRemoteURL(...)`\n * to create a `url` for the script.\n *\n * Other methods are designed for internal use only.\n */\nexport class Script {\n  static DEFAULT_TIMEOUT = 30000; // 30s\n\n  /**\n   * Get URL of a script hosted on development server.\n   *\n   * @param scriptId Id of the script.\n   */\n  static getDevServerURL(scriptId: string) {\n    return (webpackContext: WebpackContext) =>\n      `${webpackContext.p}${webpackContext.u(scriptId)}`;\n  }\n\n  /**\n   * Get URL of a script stored on filesystem on the target mobile device.\n   *\n   * @param scriptId Id of the script.\n   */\n  static getFileSystemURL(scriptId: string) {\n    return (webpackContext: WebpackContext) =>\n      webpackContext.u(`file:///${scriptId}`);\n  }\n\n  /**\n   * Get URL of a script hosted on a remote server.\n   *\n   * By default `.chunk.bundle` extension will be added to the URL.\n   * If your script has different extension, you should pass `{ excludeExtension: true }` as 2nd argument.\n   *\n   * @param url A URL to remote location where the script is stored.\n   * @param options Additional options.\n   */\n  static getRemoteURL(\n    url: string,\n    options: { excludeExtension?: boolean } = {}\n  ) {\n    if (options.excludeExtension) {\n      return url;\n    }\n\n    return (webpackContext: WebpackContext) => webpackContext.u(url);\n  }\n\n  /**\n   * Create new instance of `Script` from non-normalized script locator data.\n   *\n   * @param locator Non-normalized locator data.\n   * @param fetch Initial flag for whether script should be fetched or not.\n   *\n   * @internal\n   */\n  static from(\n    key: { scriptId: string; caller?: string },\n    locator: ScriptLocator,\n    fetch: boolean\n  ) {\n    const headers: Record<string, string> = {};\n    new Headers(locator.headers).forEach((value: string, key: string) => {\n      headers[key.toLowerCase()] = value;\n    });\n\n    let body: NormalizedScriptLocator['body'];\n    if (locator.body instanceof FormData) {\n      const bodyObject: Record<string, string> = {};\n      locator.body.forEach((value, key) => {\n        if (typeof value === 'string') {\n          bodyObject[key] = value;\n        } else {\n          console.warn('Script does not support File as FormData key in body');\n        }\n      });\n      body = JSON.stringify(bodyObject);\n    } else if (locator.body instanceof URLSearchParams) {\n      const bodyObject: Record<string, string> = {};\n      locator.body.forEach((value, key) => {\n        bodyObject[key] = value;\n      });\n      body = JSON.stringify(bodyObject);\n    } else {\n      body = locator.body ?? undefined;\n    }\n\n    if (typeof locator.url === 'function') {\n      throw new Error('Property url as a function is not support');\n    }\n\n    return new Script(\n      key.scriptId,\n      key.caller,\n      {\n        method: locator.method ?? 'GET',\n        url: locator.url,\n        absolute: locator.absolute ?? false,\n        timeout: locator.timeout ?? Script.DEFAULT_TIMEOUT,\n        query: new URLSearchParams(locator.query).toString() || undefined,\n        body,\n        headers: Object.keys(headers).length ? headers : undefined,\n        fetch: locator.cache === false ? true : fetch,\n        verifyScriptSignature: locator.verifyScriptSignature ?? 'off',\n      },\n      locator.cache\n    );\n  }\n\n  /**\n   * Constructs new representation of a script.\n   *\n   * @param locator Normalized locator data.\n   * @param cache Flag whether use cache or not, `true` by default.\n   *\n   * @internal\n   */\n  constructor(\n    public readonly scriptId: string,\n    public readonly caller: string | undefined,\n    public readonly locator: NormalizedScriptLocator,\n    public readonly cache: boolean = true\n  ) {}\n\n  /**\n   * Check if the script was already cached and cache should be updated with new data.\n   *\n   * @param cachedData Cached data for the same script.\n   *\n   * @internal\n   */\n  shouldUpdateCache(\n    cachedData: Pick<\n      NormalizedScriptLocator,\n      'method' | 'url' | 'query' | 'headers' | 'body'\n    >\n  ) {\n    if (!this.cache || !cachedData) {\n      return false;\n    }\n\n    return this.checkIfCacheDataOutdated(cachedData);\n  }\n\n  /**\n   * Check if the script should be fetched again or reused,\n   * based on previous cached data.\n   *\n   * @param cachedData Cached data for the same script.\n   *\n   * @internal\n   */\n  shouldRefetch(\n    cachedData: Pick<\n      NormalizedScriptLocator,\n      'method' | 'url' | 'query' | 'headers' | 'body'\n    >\n  ) {\n    if (!this.cache) {\n      return true;\n    }\n\n    return this.checkIfCacheDataOutdated(cachedData);\n  }\n\n  /**\n   * Check if previous cached data is the same as the new one.\n   *\n   * @param cachedData Cached data for the same script.\n   *\n   * @internal\n   */\n  checkIfCacheDataOutdated(\n    cachedData: Pick<\n      NormalizedScriptLocator,\n      'method' | 'url' | 'query' | 'headers' | 'body'\n    >\n  ) {\n    const diffs = [\n      cachedData.method !== this.locator.method,\n      cachedData.url !== this.locator.url,\n      cachedData.query !== this.locator.query,\n      !shallowEqual(cachedData.headers, this.locator.headers),\n      cachedData.body !== this.locator.body,\n    ];\n\n    return diffs.some((diff) => diff);\n  }\n\n  /**\n   * Get object to store in cache.\n   *\n   * @internal\n   */\n  getCacheData() {\n    return {\n      method: this.locator.method,\n      url: this.locator.url,\n      query: this.locator.query,\n      headers: this.locator.headers,\n      body: this.locator.body,\n    };\n  }\n\n  toObject() {\n    return {\n      scriptId: this.scriptId,\n      caller: this.caller,\n      locator: this.locator,\n      cache: this.cache,\n    };\n  }\n}\n","/* globals __DEV__, __webpack_require__ */\nimport EventEmitter from 'events';\nimport { NativeModules } from 'react-native';\nimport { getWebpackContext } from './getWebpackContext';\nimport { Script } from './Script';\nimport type {\n  NormalizedScriptLocator,\n  ScriptLocatorResolver,\n  StorageApi,\n} from './types';\n\ntype Cache = Record<\n  string,\n  Pick<NormalizedScriptLocator, 'method' | 'url' | 'query' | 'headers' | 'body'>\n>;\n\nconst CACHE_KEY = `Repack.ScriptManager.Cache.v3.${\n  __DEV__ ? 'debug' : 'release'\n}`;\n\n/* Options for resolver when adding it to a `ScriptManager`. */\nexport interface ResolverOptions {\n  /**\n   * Priority of the resolver. Defaults to `2`.\n   * Resolvers are called based on the highest priority,\n   * so higher the number, the higher priority the resolver gets.\n   */\n  priority?: number;\n}\n\n/**\n * A manager to ease resolution, downloading and executing additional code from:\n * - arbitrary JavaScript scripts\n * - Webpack chunks\n * - Webpack bundles\n * - Webpack MF containers\n *\n * ScriptManager is globally available under `ScriptManager.shared` in main bundle, chunks and containers.\n *\n * Use `ScriptManager.shared` instead of creating new instance of `ScriptManager`.\n *\n * This API is mainly useful, if you are working with any form of Code Splitting.\n *\n * `ScriptManager` is also an `EventEmitter` and emits the following events:\n * - `resolving` with `{ scriptId, caller }`\n * - `resolved` with `scriptId: string, caller?: string, locator: NormalizedScriptLocator, cache: boolean`\n * - `prefetching` with `scriptId: string, caller?: string, locator: NormalizedScriptLocator, cache: boolean`\n * - `loading` with `scriptId: string, caller?: string, locator: NormalizedScriptLocator, cache: boolean`\n * - `loaded` with `scriptId: string, caller?: string, locator: NormalizedScriptLocator, cache: boolean`\n * - `error` with `error: Error`\n *\n * Example of using this API with async Webpack chunk:\n * ```js\n * import * as React from 'react';\n * import { ScriptManager, Script } from '@callstack/repack/client';\n *\n * ScriptManager.shared.addResolver(async (scriptId) => {\n *   if (__DEV__) {\n *     return {\n *       url: Script.getDevServerURL(scriptId);\n *       cache: false,\n *     };\n *   }\n *\n *   return {\n *     url: Script.getRemoteURL(`http://domain.exaple/apps/${scriptId}`),\n *   };\n * });\n *\n * // ScriptManager.shared.loadScript is called internally when running `import()`\n * const TeacherModule = React.lazy(() => import('./Teacher.js'));\n * const StudentModule = React.lazy(() => import('./Student.js'));\n *\n * export function App({ role }) {\n *   if (role === 'teacher') {\n *     return <TeacherModule />;\n *   }\n *\n *   return <StudentModule />\n * }\n * ```\n */\nexport class ScriptManager extends EventEmitter {\n  static get shared(): ScriptManager {\n    if (!__webpack_require__.repack.shared.scriptManager) {\n      __webpack_require__.repack.shared.scriptManager = new ScriptManager();\n    }\n    return __webpack_require__.repack.shared.scriptManager;\n  }\n\n  protected cache: Cache = {};\n  protected cacheInitialized = false;\n  protected resolvers: [number, ScriptLocatorResolver][] = [];\n  protected storage?: StorageApi;\n\n  /**\n   * Constructs instance of `ScriptManager`.\n   *\n   * __Should not be called directly__ - use `ScriptManager.shared`.\n   *\n   * @internal\n   */\n  protected constructor(\n    private nativeScriptManager = NativeModules.ScriptManager\n  ) {\n    super();\n\n    if (!nativeScriptManager) {\n      throw new Error(\n        'repack react-native module was not found.' +\n          (__DEV__ ? ' Did you forget to update native dependencies?' : '')\n      );\n    }\n\n    if (__webpack_require__.repack.shared.scriptManager) {\n      throw new Error(\n        'ScriptManager was already instantiated. Use ScriptManager.shared instead.'\n      );\n    }\n\n    __webpack_require__.repack.shared.loadScriptCallback.push = ((\n      parentPush: typeof Array.prototype.push,\n      ...data: string[][]\n    ) => {\n      const [[scriptId, caller]] = data;\n      this.emit('__loaded__', { scriptId, caller });\n      return parentPush(...data);\n    }).bind(\n      null,\n      __webpack_require__.repack.shared.loadScriptCallback.push.bind(\n        __webpack_require__.repack.shared.loadScriptCallback\n      )\n    );\n\n    __webpack_require__.repack.shared.scriptManager = this;\n  }\n\n  __destroy() {\n    __webpack_require__.repack.shared.scriptManager = undefined;\n    __webpack_require__.repack.shared.loadScriptCallback.push =\n      Array.prototype.push.bind(\n        __webpack_require__.repack.shared.loadScriptCallback\n      );\n  }\n\n  /**\n   * Sets a storage backend to cache resolved scripts locator data.\n   *\n   * The stored data is used to detect if scripts locator data of previously downloaded\n   * script hasn't changed to avoid over-fetching the script.\n   *\n   * @param storage Implementation of storage functions.\n   */\n  setStorage(storage?: StorageApi) {\n    this.storage = storage;\n  }\n\n  /**\n   * Adds new script locator resolver.\n   *\n   * Resolver is an async function to resolve script locator data - in other words, it's a function to\n   * tell the {@link ScriptManager} how to fetch the script.\n   *\n   * There's no limitation on what logic you can run inside this function - it can include:\n   * - fetching/loading remote config\n   * - fetching/loading feature flags\n   * - fetching/loading A/B testing data\n   * - calling native modules\n   * - running arbitrary logic\n   *\n   * @param resolver Resolver function to add.\n   * @param options Resolver options.\n   */\n  addResolver(\n    resolver: ScriptLocatorResolver,\n    { priority = 2 }: ResolverOptions = {}\n  ) {\n    this.resolvers = this.resolvers\n      .concat([[priority, resolver]])\n      .sort(([a], [b]) => b - a);\n  }\n\n  /**\n   * Removes previously added resolver.\n   *\n   * @param resolver Resolver function to remove.\n   * @returns `true` if resolver was found and removed, `false` otherwise.\n   */\n  removeResolver(resolver: ScriptLocatorResolver): boolean {\n    const index = this.resolvers.findIndex(([, item]) => item === resolver);\n    if (index > -1) {\n      this.resolvers.splice(index, 1);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Removes all previously added resolvers.\n   */\n  removeAllResolvers() {\n    this.resolvers = [];\n  }\n\n  protected async initCache() {\n    if (!this.cacheInitialized) {\n      const cache: Cache | null | undefined = JSON.parse(\n        (await this.storage?.getItem(CACHE_KEY)) ?? '{}'\n      );\n      this.cache = cache ?? {};\n      this.cacheInitialized = true;\n    }\n  }\n\n  protected async saveCache() {\n    await this.storage?.setItem(CACHE_KEY, JSON.stringify(this.cache));\n  }\n\n  protected handleError(error: any, message: string, ...args: any[]): never {\n    console.error(message, ...args, { originalError: error });\n    this.emit('error', { message, args, originalError: error });\n    throw error;\n  }\n\n  /**\n   * Resolves a {@link Script} instance with normalized locator data.\n   *\n   * Resolution will use previously added (via `ScriptManager.shared.addResolver(...)`) resolvers\n   * in series, util one returns a locator data or will throw if no resolver handled the request.\n   *\n   * Use `ScriptManager.shared.on('resolving', ({ scriptId, caller }) => { })` to listen for when\n   * the script resolution begins.\n   *\n   * Use `ScriptManager.shared.on('resolved', (script) => { })` to listen for when\n   * the script's locator data is resolved.\n   *\n   * @param scriptId Id of the script to resolve.\n   * @param caller Name of the calling script - it can be for example: name of the bundle, chunk or container.\n   */\n  async resolveScript(\n    scriptId: string,\n    caller?: string,\n    webpackContext = getWebpackContext()\n  ): Promise<Script> {\n    await this.initCache();\n    try {\n      if (!this.resolvers.length) {\n        throw new Error(\n          'No script resolvers were added. Did you forget to call `ScriptManager.shared.addResolver(...)`?'\n        );\n      }\n\n      this.emit('resolving', { scriptId, caller });\n\n      let locator;\n      for (const [, resolve] of this.resolvers) {\n        locator = await resolve(scriptId, caller);\n        if (locator) {\n          break;\n        }\n      }\n\n      if (!locator) {\n        throw new Error(`No resolver was able to resolve script ${scriptId}`);\n      }\n\n      if (typeof locator.url === 'function') {\n        locator.url = locator.url(webpackContext);\n      }\n\n      const script = Script.from({ scriptId, caller }, locator, false);\n      const cacheKey = `${scriptId}_${caller ?? 'unknown'}`;\n\n      // Check if user provided a custom shouldUpdateScript function\n      if (locator.shouldUpdateScript) {\n        // If so, we need to wait for it to resolve\n        const fetch = await locator.shouldUpdateScript(\n          scriptId,\n          caller,\n          script.shouldUpdateCache(this.cache[cacheKey])\n        );\n\n        // If it returns true, we need to fetch the script\n        if (fetch) {\n          script.locator.fetch = true;\n          this.cache[cacheKey] = script.getCacheData();\n          await this.saveCache();\n        }\n\n        this.emit('resolved', script.toObject());\n\n        // if it returns false, we don't need to fetch the script\n        return script;\n      }\n\n      // If no custom shouldUpdateScript function was provided, we use the default behaviour\n      if (!this.cache[cacheKey]) {\n        script.locator.fetch = true;\n        this.cache[cacheKey] = script.getCacheData();\n        await this.saveCache();\n      } else if (script.shouldRefetch(this.cache[cacheKey])) {\n        script.locator.fetch = true;\n        this.cache[cacheKey] = script.getCacheData();\n        await this.saveCache();\n      }\n\n      this.emit('resolved', script.toObject());\n\n      return script;\n    } catch (error) {\n      this.handleError(\n        error,\n        '[ScriptManager] Failed while resolving script locator:',\n        { scriptId, caller }\n      );\n    }\n  }\n\n  /**\n   * Resolves given script's location, downloads and executes it.\n   * The execution of the code is handled internally by threading in React Native.\n   *\n   * Use `ScriptManager.shared.on('loading', (script) => { })` to listen for when\n   * the script is about to be loaded.\n   *\n   * Use `ScriptManager.shared.on('loaded', (script) => { })` to listen for when\n   * the script is loaded.\n   *\n   * @param scriptId Id of the script to load.\n   * @param caller Name of the calling script - it can be for example: name of the bundle, chunk or container.\n   */\n  async loadScript(\n    scriptId: string,\n    caller?: string,\n    webpackContext = getWebpackContext()\n  ) {\n    let script = await this.resolveScript(scriptId, caller, webpackContext);\n    return await new Promise<void>((resolve, reject) => {\n      (async () => {\n        const onLoaded = (data: { scriptId: string; caller?: string }) => {\n          if (data.scriptId === scriptId && data.caller === caller) {\n            this.emit('loaded', script.toObject());\n            resolve();\n          }\n        };\n\n        try {\n          this.emit('loading', script.toObject());\n          this.on('__loaded__', onLoaded);\n          await this.nativeScriptManager.loadScript(scriptId, script.locator);\n        } catch (error) {\n          const { code } = error as Error & { code: string };\n          this.handleError(\n            error,\n            '[ScriptManager] Failed to load script:',\n            code ? `[${code}]` : '',\n            script.toObject()\n          );\n        } finally {\n          this.removeListener('__loaded__', onLoaded);\n        }\n      })().catch((error) => {\n        reject(error);\n      });\n    });\n  }\n\n  /**\n   * Resolves given script's location and downloads it without executing.\n   * This function can be awaited to detect if the script was downloaded and for error handling.\n   *\n   * Use `ScriptManager.shared.on('prefetching', (script) => { })` to listen for when\n   * the script's prefetch beings.\n   *\n   * @param scriptId Id of the script to prefetch.\n   * @param caller Name of the calling script - it can be for example: name of the bundle, chunk or container.\n   */\n  async prefetchScript(\n    scriptId: string,\n    caller?: string,\n    webpackContext = getWebpackContext()\n  ) {\n    let script = await this.resolveScript(scriptId, caller, webpackContext);\n\n    try {\n      this.emit('prefetching', script.toObject());\n      await this.nativeScriptManager.prefetchScript(scriptId, script.locator);\n    } catch (error) {\n      const { code } = error as Error & { code: string };\n      this.handleError(\n        error,\n        '[ScriptManager] Failed to prefetch script:',\n        code ? `[${code}]` : '',\n        script.toObject()\n      );\n    }\n  }\n\n  /**\n   * Clears the cache (if configured in {@link ScriptManager.setStorage}) and removes downloaded\n   * files for given scripts from the filesystem. This function can be awaited to detect if the\n   * scripts were invalidated and for error handling.\n   *\n   * Use `ScriptManager.shared.on('invalidated', (scriptIds) => { })` to listen for when\n   * the invalidation completes.\n   *\n   * @param scriptIds Array of script ids to clear from cache and remove from filesystem.\n   */\n  async invalidateScripts(scriptIds: string[] = []) {\n    try {\n      await this.initCache();\n      const ids = scriptIds ?? Object.keys(this.cache);\n\n      for (const scriptId of ids) {\n        delete this.cache[scriptId];\n      }\n      await this.saveCache();\n\n      await this.nativeScriptManager.invalidateScripts(ids);\n      this.emit('invalidated', ids);\n    } catch (error) {\n      const { code } = error as Error & { code: string };\n      this.handleError(\n        error,\n        '[ScriptManager] Failed to invalidate scripts:',\n        code ? `[${code}]` : ''\n      );\n    }\n  }\n}\n","import { ScriptManager } from './ScriptManager';\nimport type { WebpackContext } from './types';\n\n/**\n * Namespace for runtime utilities for Module Federation.\n */\nexport namespace Federated {\n  /**\n   * Resolves URL to a container or a chunk when using Module Federation,\n   * based on given `scriptId` and `caller`.\n   */\n  export type URLResolver = (\n    scriptId: string,\n    caller?: string\n  ) => string | ((webpackContext: WebpackContext) => string) | undefined;\n\n  /**\n   * Configuration options for {@link createURLResolver} for Module Federation.\n   * Allows to configure how created {@link URLResolver} will behave.\n   */\n  export interface URLResolverConfig {\n    /**\n     * A Module Federation container names to URL templates mapping.\n     *\n     * The key in the object is a container name and the value is a template\n     * that will be used to resolve a URL.\n     *\n     * Accepted template params:\n     * - `[name]` - Container name\n     * - `[ext]` - Container extension, eg: `.container.bundle`\n     *\n     * You can omit `[ext]`, if you're using custom extension, in which case, you should\n     * provide extension explicitly. When using custom extension, it's recommended to\n     * provide a URL template for chunks as well using `chunks` property.\n     *\n     * @example\n     * ```ts\n     * {\n     *   containers: {\n     *     app1: 'http://localhost:9000/[name][ext]'\n     *   }\n     * }\n     * ```\n     */\n    containers: Record<string, string>;\n\n    /**\n     * An optional Module Federation container names to URL templates mapping.\n     *\n     * The key in the object is a container names and the value is a template\n     * that will be used to resolve a __chunk__ URL for that container.\n     *\n     * Specifying this property is useful if:\n     * - containers have custom extension (different from `.container.bundle`)\n     * - chunks have custom extensions (different from `.chunk.bundle`)\n     * - chunks have different URL that containers\n     *\n     * When this property is left unspecified, the template URLs are inferred from\n     * `containers` property. The following:\n     * ```\n     * {\n     *   containers: {\n     *     app1: 'http://localhost:9000/[name][ext]\n     *     app2: 'http://localhost:9000/[name].js\n     *   },\n     * }\n     * ```\n     * is equivalent to:\n     * ```ts\n     * {\n     *   containers: {\n     *     app1: 'http://localhost:9000/[name][ext]',\n     *     app2: 'http://localhost:9000/[name].js',\n     *   },\n     *   chunks: {\n     *     app1: 'http://localhost:9000/[name][ext]',\n     *     app2: 'http://localhost:9000/[name].js',\n     *   },\n     * }\n     * ```\n     *\n     * Accepted template params:\n     * - `[name]` - Container name\n     * - `[ext]` - Chunk extension, eg: `.chunk.bundle`\n     *\n     * @example\n     * ```ts\n     * {\n     *   containers: {\n     *     app1: 'http://localhost:9000/[name].container.js',\n     *   },\n     *   chunks: {\n     *     app1: 'http://localhost:9000/chunks/[name][ext]',\n     *   }\n     * }\n     * ```\n     */\n    chunks?: Record<string, string>;\n  }\n\n  /**\n   * Creates URL resolver for Module Federation from provided config.\n   *\n   * @example\n   * ```ts\n   * import { ScriptManager, Script, Federated } from '@callstack/repack/client';\n   *\n   * const resolveURL = Federated.createURLResolver({\n   *   containers: {\n   *     app1: 'http://localhost:9001/[name][ext]',\n   *     app2: 'http://localhost:9002/[name].container.js',\n   *   },\n   *   chunks: {\n   *     app2: 'http://localhost:9002/chunks/[name][ext]',\n   *   },\n   * });\n   *\n   * ScriptManager.shared.addResolver(async (scriptId, caller) => {\n   *   let url;\n   *   if (caller === 'main') {\n   *     url = __DEV__\n   *       ? Script.getDevServerURL(scriptId)\n   *       : Script.getRemoteURL(`http://localhost:9000/${scriptId}`);\n   *   } else {\n   *     url = resolveURL(scriptId, caller);\n   *   }\n   *\n   *   if (!url) {\n   *     return undefined;\n   *   }\n   *\n   *   return {\n   *     url,\n   *     query: {\n   *       platform: Platform.OS,\n   *     },\n   *   };\n   * });\n   * ```\n   *\n   * `createURLResolver` is a abstraction over {@link Script.getRemoteURL},\n   * for example:\n   * ```ts\n   * import { ScriptManager, Federated } from '@callstack/repack/client';\n   *\n   * ScriptManager.shared.addResolver((scriptId, caller) => {\n   *   const resolveURL = Federated.createURLResolver({\n   *     containers: {\n   *       app1: 'http://localhost:9000/[name][ext]',\n   *     },\n   *   });\n   *\n   *   return {\n   *     url: resolveURL(scriptId, caller);\n   *   };\n   * });\n   * ```\n   * is equivalent to:\n   * ```ts\n   * import { ScriptManager, Script } from '@callstack/repack/client';\n   *\n   * ScriptManager.shared.addResolver(async (scriptId, caller) => {\n   *   if (scriptId === 'app1') {\n   *     return {\n   *       url: 'http://localhost:9000/app1.container.bundle',\n   *     };\n   *   }\n   *\n   *   if (caller === 'app1') {\n   *     return {\n   *       url: Script.getRemoteURL(`http://localhost:9000/${scriptId}`),\n   *     };\n   *   }\n   * });\n   * ```\n   *\n   * @param config Configuration for the resolver.\n   * @returns A resolver function which will try to resolve URL based on given `scriptId` and `caller`.\n   */\n  export function createURLResolver(\n    config: Federated.URLResolverConfig\n  ): Federated.URLResolver {\n    const resolvers: Record<string, Federated.URLResolver> = {};\n\n    for (const key in config.containers) {\n      resolvers[key] = (scriptId: string, caller?: string) => {\n        if (scriptId === key) {\n          const url = config.containers[key]\n            .replace(/\\[name\\]/g, scriptId)\n            .replace(/\\[ext\\]/g, '.container.bundle');\n          return url;\n        }\n\n        if (caller === key) {\n          const url = (config.chunks?.[key] ?? config.containers[key]).replace(\n            /\\[name\\]/g,\n            scriptId\n          );\n\n          if (url.includes('[ext]')) {\n            return (webpackContext: WebpackContext) =>\n              webpackContext.u(url.replace(/\\[ext\\]/g, ''));\n          }\n\n          return url;\n        }\n\n        return undefined;\n      };\n    }\n\n    return (scriptId, caller) => {\n      const resolver =\n        (caller ? resolvers[caller] : undefined) ?? resolvers[scriptId];\n\n      return resolver(scriptId, caller);\n    };\n  }\n\n  declare function __webpack_init_sharing__(scope: string): Promise<void>;\n  declare var __webpack_share_scopes__: Record<string, any>;\n  declare var self: Record<string, any>;\n\n  /**\n   * Dynamically imports module from a Module Federation container. Similar to `import('file')`, but\n   * specific to Module Federation. Calling `importModule` will create an async boundary.\n   *\n   * Container will be evaluated only once. If you use `importModule` for the same container twice,\n   * the container will be loaded and evaluated only on the first import.\n   *\n   * Under the hood, `importModule` will call `ScriptManager.shared.loadScript(containerName)`.\n   * This means, a resolver must be added with `ScriptManager.shared.addResolver(...)` beforehand and provided proper\n   * resolution logic to resolve URL based on the `containerName`.\n   *\n   * @param containerName Name of the container - should be the same name provided to\n   * `webpack.container.ModuleFederationPlugin` in `library.name`.\n   * @param module Full name with extension of the module to import from the container - only modules\n   * exposed in `exposes` in `webpack.container.ModuleFederationPlugin` can be used.\n   * @param scope Optional, scope for sharing modules between containers. Defaults to `'default'`.\n   * @returns Exports of given `module` from given container.\n   *\n   * @example\n   * ```ts\n   * import * as React from 'react';\n   * import { Federated } from '@callstack/repack/client';\n   *\n   * const Button = React.lazy(() => Federated.importModule('my-components', './Button.js'));\n   *\n   * const myUtil = await Federated.importModule('my-lib', './myUtil.js');\n   * ```\n   */\n  export async function importModule<Exports = any>(\n    containerName: string,\n    module: string,\n    scope: string = 'default'\n  ): Promise<Exports> {\n    if (\n      !__webpack_share_scopes__[scope] ||\n      !__webpack_share_scopes__[scope].__isInitialized\n    ) {\n      // Initializes the share scope.\n      // This fills it with known provided modules from this build and all remotes.\n      await __webpack_init_sharing__(scope);\n      __webpack_share_scopes__[scope].__isInitialized = true;\n    }\n\n    // Do not use `const container = self[containerName];` here. Once container is loaded\n    // `container` reference is not updated, so `container.__isInitialized`\n    // will crash the application, because of reading property from `undefined`.\n    if (!self[containerName]) {\n      // Download and execute container\n      await ScriptManager.shared.loadScript(containerName);\n    }\n\n    const container = self[containerName];\n\n    if (!container.__isInitialized) {\n      container.__isInitialized = true;\n      // Initialize the container, it may provide shared modules\n      await container.init(__webpack_share_scopes__[scope]);\n    }\n\n    const factory = await container.get(module);\n    const exports = factory();\n    return exports;\n  }\n}\n","/* globals __webpack_require__ */\n\nimport type { WebpackContext } from './types';\n\n/**\n * Get Webpack runtime context form current JavaScript scope.\n *\n * __You likely don't need to use it.__\n */\nexport function getWebpackContext(): WebpackContext {\n  return __webpack_require__;\n}\n","export * from './ScriptManager';\nexport * from './Script';\nexport * from './types';\nexport * from './getWebpackContext';\nexport { Federated } from './federated';\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","//\n\nmodule.exports = function shallowEqual(objA, objB, compare, compareContext) {\n  var ret = compare ? compare.call(compareContext, objA, objB) : void 0;\n\n  if (ret !== void 0) {\n    return !!ret;\n  }\n\n  if (objA === objB) {\n    return true;\n  }\n\n  if (typeof objA !== \"object\" || !objA || typeof objB !== \"object\" || !objB) {\n    return false;\n  }\n\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);\n\n  // Test for A's keys different from B.\n  for (var idx = 0; idx < keysA.length; idx++) {\n    var key = keysA[idx];\n\n    if (!bHasOwnProperty(key)) {\n      return false;\n    }\n\n    var valueA = objA[key];\n    var valueB = objB[key];\n\n    ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;\n\n    if (ret === false || (ret === void 0 && valueA !== valueB)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n"],"names":["Script","constructor","scriptId","caller","locator","cache","shouldUpdateCache","cachedData","checkIfCacheDataOutdated","shouldRefetch","diffs","method","url","query","shallowEqual","headers","body","some","diff","getCacheData","toObject","webpackContext","p","u","options","excludeExtension","key","fetch","Headers","forEach","value","toLowerCase","FormData","bodyObject","console","warn","JSON","stringify","URLSearchParams","undefined","Error","absolute","timeout","DEFAULT_TIMEOUT","toString","Object","keys","length","verifyScriptSignature","CACHE_KEY","__DEV__","ScriptManager","nativeScriptManager","NativeModules","cacheInitialized","resolvers","__webpack_require__","repack","shared","scriptManager","loadScriptCallback","push","parentPush","data","emit","bind","__destroy","Array","prototype","setStorage","storage","addResolver","resolver","priority","concat","sort","a","b","removeResolver","index","findIndex","item","splice","removeAllResolvers","parse","getItem","setItem","handleError","error","message","args","originalError","getWebpackContext","initCache","resolve","script","from","cacheKey","shouldUpdateScript","saveCache","resolveScript","Promise","reject","onLoaded","on","loadScript","code","removeListener","catch","prefetchScript","scriptIds","ids","invalidateScripts","EventEmitter","createURLResolver","config","containers","replace","chunks","includes","importModule","containerName","module","scope","__webpack_share_scopes__","__isInitialized","__webpack_init_sharing__","self","container","init","factory","get","exports","Federated"],"sourceRoot":""}